# 软件分析第二次大作业

### 算法概述

设计了一个较为高效的 Example Based Synthesis 算法，具有如下的特点：

1. 效率高，可以在时间限制能正确生成本次大作业 open_tests 中的**所有**测试用例。

2. 结果简洁，可以生成 “极简” 的程序，下面是本算法生成的两个例子：

   ```scheme
   (define-fun max6 ((x1 Int) (x2 Int) (x3 Int) (x4 Int) (x5 Int) (x6 Int)) Int (ite (and (and (and (and (<= x2 x1) (<= x3 x1)) (<= x4 x1)) (<= x5 x1)) (<= x6 x1)) x1 (ite (and (and (and (<= x3 x2) (<= x4 x2)) (<= x5 x2)) (<= x6 x2)) x2 (ite (and (and (<= x4 x3) (<= x5 x3)) (<= x6 x3)) x3 (ite (and (<= x5 x4) (<= x6 x4)) x4 (ite (<= x6 x5) x5 x6))))))
   ```

   ```scheme
   (define-fun findIdx ((y1 Int) (y2 Int) (y3 Int) (k1 Int)) Int (ite (or (or (or (or (<= y2 y1) (<= y3 y2)) (<= k1 y1)) (= y3 k1)) (= y2 k1)) 0 (ite (<= k1 y2) 1 (ite (<= k1 y3) 2 3))))
   ```

   其中第一个程序是 `max6` 的答案，第二个程序是 `array_search_3`。值得注意的是，在 `array_serach_3` 中，并没有对序列无序或者 $k1$ 和数列中某一个元素值相同的情况进行约束，可以发现在我们的算法把这个约束准确地求出了。


### 算法过程

算法主要分成三部分：

1. 求出可能作为返回值的表达式集合（不含 `ite`） $R$。
2. 求出可能出现在 if 条件里的比较表达式（形如 $x \leq, <, = y$）集合 $C$。
3. 对 $R$ 中的每一个元素生成一个它作为返回值的条件（以析取范式的形式）。

目前本算法只能处理在输入中，所有输入均以 $(f\ x\ y\ z)$ 形式出现的情况。因此在读入输入的时候，算法会先尝试把所有 $f$ 的调用变换成相同的形式，碰到不能变换的情况（例如一个等号两端出现了参数不同的两次调用）会转而用更加暴力的方法求解。

这儿定义 $\phi_t(I)$ 为把输入约束中的所有 $(f\ x\ y\ z)$ 都替换成表达式 $t$ 后的约束，其中 $I$ 为输入变量。

#### 第一部分

可以判断一个表达式集合 $R$ 是否覆盖了 $f$ 的所有返回值，即下列布尔表达式不可满足：
$$
\neg (\phi_\text{value}(I)) \wedge \bigvee_{t \in R} [\text{value} = t])
$$
因为在测试集中，返回值的形式都非常简单，因此这儿使用最暴力的方法，令 $R(k)$ 为包含 $k$ 个运算符（不含 `ite`）的所有表达式集合，直接找到最小的 $k$ 使得 $R(k)$ 满足条件。

因为这样找到的 $R(k)$ 非常大，因此使用了简单的二分来去重，找到一个极小的满足条件集合作为 $R$ 返回。因为在 `Int` 范围内，很难出现两个不同的表达式集合 $A,B$ 对应的取值集合是完全相同的情况，因此该算法能非常精确的找到 $R$。

当返回值形式比较复杂的时候，也可以用一个 example based synthesis 来生成表达式（每次找到一个反例再生成一个表达式覆盖它）。

#### 第二部分

因为测试集中，条件判断的形式都非常简单，因此这儿令 $C(k)$ 为包含 $k$ 个运算符的比较表达式。从小到大依次尝试用 $C(k)$ 进行生成，直到正确的生成出程序为止。

#### 第三部分

我们以析取范式的形式来生成答案，即对每一个返回值，生成一系列的集合 $P_i \subseteq C$，对应的布尔表达式为: $\bigvee_{P_i} \bigwedge_{t \in P_i} t$.

设 $R$ 中的元素为 $t_1$ 至 $t_n$，当前正在生成 $t_k$，设 $t_1$ 至 $t_k$ 目前已有的条件为 $f_i(I)$。则可以从如下约束来生成一个返回值应该是 $t_k$ 且不能被当前表示的 example:
$$
\phi_{\text{value}}(I) \wedge \bigwedge _{i=1}^k (\neg f_{i}(I)) \wedge \bigwedge _{i=k+1}^n [\text{value} \neq t_i] \wedge [\text{value} = t_k]
$$
如果这个表达式 unsat，则说明 $f_k$ 的生成已经完成，可以继续生成接下来的变量，否则它的 model 就是一个范反例$e$。

为了通过这个 example，需要扩大 $f_k$，即在 $f_k$ 中加入一个新的集合 $P$，使得 $P$ 在 $e$ 上为真。可以从 $C$ 中找到所有在 $e$ 下为真的集合 $S$，则真实的 $P$ 一定是 $S$ 的子集。

我们可以用如下的约数来判断一个集合 $P$ 能不能被加入答案，设 $P$ 对应的布尔表达式为 $P(I)$
$$
(\neg \phi_{\text{value}}(I)) \wedge \bigwedge _{i=1}^k(\neg f_i(I)) \wedge P(I) \wedge [\text{value} = t_k]
$$
如果这个表达式 sat，说明集合 $P$ 太容易被满足，把不满足答案的解加进来了，否则说明加入集合 $P$ 程序还是正确的。

可以先检查 $S$ 能不能别加入答案，如果不能，说明当前无法继续生成了，原因是集合 $C$ 不够大，算法会返回第二部分生成一个更大的集合 $C$ 来生成。

直接加入 $S$ 会产生较为严重的过拟合，因此同样采用了二分的方法来取得 $S$ 的一个极小子集来作为 $P$。

#### 第三部分对过拟合的处理

上述的算法在 `max` 中仍然会产生严重的过拟合，`max10` 里会产生 $173K$ 长度的代码。

考虑在析取范式中不存在 `or` 的情况，即可以用一个 $P$ 集合来表出条件。在这种情况下，上述算法相当于在取值为 $t_k$ 的空间中，每次选择一个包含某个点的子空间加入答案，直到当前选择的点不能被更小的子空间表示了，才能产生正确的结果。

在已知真实答案中不存在 `or` 的前提下，可以采用更高效的做法：每一次用之前产生过的所有测试数据来筛选集合 $S$，使得 $S$ 中的每一个判断表达式，在之前每一个测试用例下均为真。

采用这样的策略，算法可以在非常快的速度内生成 `max15`。直观上来说，这个算法寻找 $P$ 的过程相当于每次扩张一个维度，而不是扩展一个子空间。（实际上，这个算法在 $|C|$ 次 SMT 求解后一定能找到答案，而之前的算法是指数级的）

但是在实际生成的时候，并不知道答案中有几个 `or`。因为我们采用了如下的扩展方法：

1. 维护若干个 example 集合 $S_i$，每产生一个新的 example，就对每一个已有的 $S_i$ 尝试把 $e$ 加入这个集合中。如果 $e$ 的加入使得集合 $S_i$ 不能被任何一个正确的条件集合 $P$ 表出，那么就制止这次加入。
2. 如果 $e$ 无法被加入任何已有的集合中，那么就加入一个新的集合，集合的元素只有 $e$ 本身。如果这个集合也不能被任何一个正确的条件集合 $P$ 表出，那么说明 $C$ 集合不够大，回到第二步。

上述算法其实是相当搞笑的。设真实解为 $\bigvee_{i=1}^n P_i$，且假设在计算反例时，反例只满足一个 $P_i$ 的概率始终大于等于 $r$，其中 $r$ 是一个大于 $0$ 的常数，则上述算法能在 $O(|C|n)$ 次 SMT 求解后，找到正确的答案。